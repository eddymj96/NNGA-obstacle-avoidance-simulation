#include "Robot.h"
#include <cmath>

WheeledRobot::WheeledRobot(NeuralNet net, Eigen::Matrix2f v_inputs, std::vector<Motors> motors,  Sensor arc_sensor, Vector24f states, Eigen::Vector3f p_axis)
: m_net(net), m_motors(motors), m_arc_sensor(arc_sensor), m_states(states), m_p_axis(p_axis)
{

}

Vector12f WheeledRobot::update_motors()
{
    Vector12f output_states;
    for(int i; i<m_motors.size(), ++i)
    {
        output_states.segment<(3*i + 2)>(3*i)m_motors[i].update();
    }

    return output_states;
}

Vector12f WheeledRobot::update_robot()
{
    // Setup Cosines and Sines

    // Cosines
    const float cphi = std::cos(m_states(phi)); 
    const float ctheta = std::cos(m_states(theta)); 
    const float cpsi = std::cos(m_states(psi));

    // Sines
    const float sphi = std::sin(m_states(phi)); 
    const float stheta = std::sin(m_states(theta)); 
    const float spsi = std::sin(m_states(psi));

    // Input Forces
    // Calculated from the torques generated by the wheels. 
    const float force_l1 = (m_motors[0].get_torque()/wheel_r);
    const float force_l2 = (m_motors[1].get_torque()/wheel_r);
    const float force_r1 = (m_motors[2].get_torque()/wheel_r);
    const float force_r2 = (m_motors[3].get_torque()/wheel_r);

    // Slip
    // calculates the slip angle for each wheel
    const float bottom = std::sqrt((m_states(u)^2)+(m_states(v)^2));
    const float beta = ((bottom == 0) ? 0 : std::asin(m_states(v)/bottom));
    const float beta = ((bottom == 0) ? 0 : std::asin(m_states(v)/bottom));

    // Propulsion Forces
    const float surge = (force_l1+force_l2+force_r1+force_r2)*std::cos(beta);
    const float sway = (force_l1+force_l2+force_r1+force_r2)*std::sin(beta);
    const float roll = m_p_axis[0];
    const float pitch = m_p_axis[1];
    const float heave = m_p_axis[2];
    const float yaw = ((force_l1+force_l2)-(force_r1+force_r2))*mr;
            

    return output_states;
}



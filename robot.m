classdef robot < handle
    properties
    % General state matrices
    x = zeros(1, 24);
    xdot = zeros(1, 24);
    
    % state variables 
    motor1;
    motor2;
    motor3;
    motor4;
    u;
    v;
    w;
    p;
    q;
    r;
    xx;  % xx because the input matrix is x
    y;
    z; 
    phi;
    theta;
    psi;
    
	Va;
    % Extra variables
    xtra_fric;
    stepSize;
    tx;
    ty;
    fz;
    
    step;
    
    % State history storage
    x_matrix;
    xdot_matrix;

    % Robot Specifications
    m = 2.148;          % Mass of robot, kg
    wheel_r = 0.0635;   % Radius of Wheel, m
    x_area = 0.0316;    % Area presented on the x-axis, m.m
    y_area = 0.0448;    % Area presented on the y-axis, m.m
    Jx = 0.0140;        % Moment of Inertia about the x-axis, kg.m.m
    Jy = 0.0252;        % Moment of Inertia about the y-axis, kg.m.m
    Jz = 0.0334;        % Moment of Inertia about the z-axis, kg.m.m
    mr = 0.1245;        % Moment Arm

    % Constants
    g = 9.81;           % Gravity, m/s.s
    Cd = 0.89;          % Drag Coefficent
    rho= 1.29;          % Air density
    W = 21.0719;        % m*g; %Weight
    end
    
    methods
        function obj = robot(xi, Va, ty, tx, fz, xtra_fric, stepSize, simTime)
            % Initialise Variables
            % Initialise Motors with [(Current, Amps), (Wheel speed,
            % rad/s) (Wheel torque, Nm), (Desired Speed)], 
            obj.motor1 = motor(xi(1), xi(2), xi(3), Va(1), xtra_fric);   
            obj.motor2 = motor(xi(4), xi(5), xi(6), Va(2), xtra_fric);
            obj.motor3 = motor(xi(7), xi(8), xi(9), Va(3), xtra_fric);
            obj.motor4 = motor(xi(10), xi(11), xi(12),Va(4), xtra_fric);

            obj.u = xi(13);
            obj.v = xi(14);
            obj.w = xi(15);
            obj.p = xi(16);
            obj.q = xi(17);
            obj.r = xi(18);
            obj.xx = xi(19);  % xx because the input matrix is x
            obj.y = xi(20);
            obj.z = xi(21);
            obj.phi = xi(22);
            obj.theta = xi(23);
            obj.psi = xi(24);
            
            obj.Va = Va;
            obj.ty = ty;
            obj.tx = tx;
            obj.fz = fz;
            obj.xtra_fric = xtra_fric;
            obj.stepSize = stepSize;
            obj.step = 1;
            
            obj.x_matrix = zeros(24, ceil(simTime/stepSize));
            obj.xdot_matrix = zeros(24, ceil(simTime/stepSize));

            obj.x = xi;
        end
        
        
        function update(obj, integrationMethod)
           %Store Variables
           obj.x_matrix(:, obj.step) = obj.x';
           obj.xdot_matrix(:, obj.step) = obj.xdot';
           
           obj.updateMotors();
           obj.updateRobot();
           
           obj.step = obj.step + 1;
           obj.x = integrationMethod(obj.x, obj.xdot, obj.stepSize);
           %display(integrationMethod(obj.x(1), obj.xdot(1), obj.stepSize));
           
            % For readability in use only
            obj.u = obj.x(13);
            obj.v = obj.x(14);
            obj.w = obj.x(15);
            obj.p = obj.x(16);
            obj.q = obj.x(17);
            obj.r = obj.x(18);
            obj.xx = obj.x(19);  % xx because the input matrix is x
            obj.y = obj.x(20);
            obj.z = obj.x(21);
            obj.phi = obj.x(22);
            obj.theta = obj.x(23);
            obj.psi = obj.x(24);

        end
        
        function updateMotors(obj)
            [obj.xdot(1), obj.xdot(2), obj.xdot(3)] = obj.motor1.update(obj.x(1:3), obj.Va(1), obj.stepSize, obj.xtra_fric);
            [obj.xdot(4), obj.xdot(5), obj.xdot(6)] = obj.motor2.update(obj.x(4:6), obj.Va(2), obj.stepSize, obj.xtra_fric);
            [obj.xdot(7), obj.xdot(8), obj.xdot(9)] = obj.motor3.update(obj.x(7:9), obj.Va(3), obj.stepSize, obj.xtra_fric);
            [obj.xdot(10), obj.xdot(11), obj.xdot(12)] = obj.motor4.update(obj.x(10:12), obj.Va(4), obj.stepSize, obj.xtra_fric);
        end
        
        function updateRobot(obj)

            
            %Used to keep psi between -180 -> +180
            if(obj.x(24)>=(pi))
                obj.x(24)=obj.x(24)-(2*pi);
            elseif(obj.x(24)<-pi)
                obj.x(24)=obj.x(24)+(2*pi);
            end
            
            % Setup Cosines and Sines
            % Cosines
            cphi = cos(obj.phi); ctheta = cos(obj.theta); cpsi = cos(obj.psi);

            % Sines
            sphi = sin(obj.phi); stheta = sin(obj.theta); spsi = sin(obj.psi);
            
           % Input Forces
            % Calculated from the torques generated by the wheels. 
            force_l1 = (obj.motor1.t/obj.wheel_r);
            force_l2 = (obj.motor2.t/obj.wheel_r);
            force_r1 = (obj.motor3.t/obj.wheel_r);
            force_r2 = (obj.motor4.t/obj.wheel_r);
            
            %---------------------------------------------------------------------%

            %---------------------------------------------------------------------%
            % Slip
            % calculates the slip angle for each wheel
            bottom = sqrt((obj.u^2)+(obj.v^2));   % calculate denominator

            if bottom == 0                  % check if 0,
                beta = 0;                    %   if 0 then no movement, no slip
            else
                beta = asin(obj.v/bottom);       % else calculate slip
            end
            %---------------------------------------------------------------------%

            %---------------------------------------------------------------------%
            % Propulsion Forces
            surge = (force_l1+force_l2+force_r1+force_r2)*cos(beta);
            sway = (force_l1+force_l2+force_r1+force_r2)*sin(beta);
            heave = obj.fz;
            roll = obj.tx;
            pitch = obj.ty;
            yaw = ((force_l1+force_l2)-(force_r1+force_r2))*obj.mr;
            %---------------------------------------------------------------------%

            %---------------------------------------------------------------------%
            % Dampening Terms
            fric_k = 0.35;
            fric_m = 0.44;
            fric_x = 0.22;
            fric_n = 0.18;
            fric_y = 1;
            fric_z = 0.3;

            % Friction
            Fx_fric = 4.6358*obj.u;     % W*fric_x*u;
            Fy_fric = 21.0719*obj.v;    % W*fric_y*v;
            Fz_fric = 6.3216*obj.w;     % W*fric_z*w;
            K_fric = 0.9182*obj.p;      % W*fric_k*mr*p;
            M_fric = 1.1543*obj.q;      % W*fric_m*mr*q;
            N_fric = 0.4722*obj.r;      % W*fric_n*mr*r;

            % Air Resistance
            % x-axis
            Fx_ar = 0.0181*obj.u*abs(obj.u); % 0.5*Cd*x_area*rho*u*abs(u);

            % Total Dampening
            X_damp = Fx_fric+Fx_ar;
            Y_damp = Fy_fric;
            Z_damp = Fz_fric;
            K_damp = K_fric;
            M_damp = M_fric;
            N_damp = N_fric;
            %---------------------------------------------------------------------%

            %---------------------------------------------------------------------%
            % Gravity Terms
            X_grav = obj.W*stheta;
            Y_grav = obj.W*sphi*ctheta;
            Z_grav = (obj.W*ctheta*cphi)-obj.W;
            %---------------------------------------------------------------------%

            %---------------------------------------------------------------------%
            % Forces and Torques
            % Forces
            X = surge-X_damp+X_grav;
            Y = sway-Y_damp+Y_grav;
            Z = heave-Z_damp+Z_grav;

            % Torques
            K = roll-K_damp;
            M = pitch-M_damp;
            N = yaw-N_damp;
            %---------------------------------------------------------------------%

            %---------------------------------------------------------------------%
            % Equations of Motion
            % Linear Accelerations
            udot = (X/obj.m)+(obj.v*obj.r)-(obj.w*obj.q);
            vdot = (Y/obj.m)+(obj.w*obj.p)-(obj.u*obj.r);
            wdot = (Z/obj.m)+(obj.u*obj.q)-(obj.v*obj.p);

            % Rotational Accelerations
            pdot = (K-((obj.Jz-obj.Jy)*obj.q*obj.r))/obj.Jx;
            qdot = (M-((obj.Jx-obj.Jz)*obj.r*obj.p))/obj.Jy;
            rdot = (N-((obj.Jy-obj.Jx)*obj.p*obj.q))/obj.Jz;
            %---------------------------------------------------------------------%

            %---------------------------------------------------------------------%
            % Kinematics
            % Linear Kinematics
            xxdot = ((cpsi*ctheta)*obj.u)+(((-spsi*cphi)-(cpsi*stheta*sphi))*obj.v)+(((spsi*sphi)-(cpsi*stheta*cphi))*obj.w); 
                % xxdot because xdot is the output matrix
            ydot = ((spsi*ctheta)*obj.u)+(((cpsi*cphi)-(spsi*stheta*sphi))*obj.v)+(((-sphi*cpsi)-(spsi*cphi*stheta))*obj.w);
            zdot = ((stheta)*obj.u)+((ctheta*sphi)*obj.v)+((ctheta*cphi)*obj.w);

            % Angular Kinematics
            % In theory +/-90 degrees for pitch is undefined but matlab tan()
            % gives it a figure. Also this situation should not occur.
            ttheta = tan(obj.theta);
            phidot = obj.p+((-sphi*ttheta)*obj.q)+((cphi*ttheta)*obj.r); 
            thetadot = ((cphi)*obj.q)+((sphi)*obj.r);
            psidot = ((-sphi/ctheta)*obj.q)+((cphi/ctheta)*obj.r);
            
            % Reassignment 

            obj.xdot(13) = udot;
            obj.xdot(14) = vdot;    
            obj.xdot(15) = wdot;
            obj.xdot(16) = pdot;
            obj.xdot(17) = qdot;
            obj.xdot(18) = rdot;
            obj.xdot(19) = xxdot;
            obj.xdot(20) = ydot;    
            obj.xdot(21) = zdot;
            obj.xdot(22) = phidot;
            obj.xdot(23) = thetadot;
            obj.xdot(24) = psidot;
        end
        
        function plotx(obj)
            
        end
    end
end